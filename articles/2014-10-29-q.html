<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width">
  <title>ActiveRecordで子の数を揮発性キャッシュに保存する</title>
  <link href="/articles/2014-10-29-q" rel="canonical">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="search" type="application/opensearchdescription+xml" title="r7kamura.com" href="/opensearch.xml">
  <meta property="og:type" content="article">
  <meta property="og:title" content="ActiveRecordで子の数を揮発性キャッシュに保存する">
  <meta property="og:url" content="https://r7kamura.com&#x2F;articles&#x2F;2014-10-29-q">
  <meta property="twitter:card" content="summary">
  <meta property="twitter:title" content="ActiveRecordで子の数を揮発性キャッシュに保存する">
</head>
<body>
  <header>
    <nav>
      <a href="/">トップページ</a>
      <ul>
        <li>
          <a href="/articles">記事</a>
        </li>
        <li>
          <a href="https://google.com/search?q=site:r7kamura.com">検索</a>
        </li>
      </ul>
    </nav>
  </header>
  <main>
    <article>
  <h1>ActiveRecordで子の数を揮発性キャッシュに保存する</h1>
  <footer>
    <p>
      <time datetime="2014-10-29T00:00:00+09:00">2014年10月29日</time>
    </p>
  </footer>
  <div>
    <p>ActiveRecordで1:Nの関係を扱うとき、ある親レコードに対して子レコードが幾つ存在するかという情報を、都度計算するのではなくキャッシュしておきたいケースは多いと思います。代表的な実装方法として、ActiveRecordのcounter cacheの機能を利用し、親レコード内にキャッシュを保存しておくという方法があります。</p>
<p>今回は、この情報を親レコード内ではなく揮発性のキャッシュに保存させるために、<a href="https://github.com/r7kamura/volatile_counter_cache">volatile_counter_cache</a>というGemをつくりました。memcachedやredisなどのKVSにキャッシュを保存することを想定しています。</p>
<h2 id="方針">方針</h2>
<p>以下のような方針に基づいたキャッシュ戦略を想定しています。</p>
<ul>
<li>RDB上には正規化された一次データだけ保存する</li>
<li>非正規化された二次データはRedis等のKVSに保存する</li>
<li>二次データは揮発しても良いようにする</li>
</ul>
<h2 id="概観">概観</h2>
<p>端的に言うと、volatile_counter_cacheは以下のように動作します。</p>
<ol>
<li>初めて必要になったときにキャッシュから取得する</li>
<li>キャッシュに無ければRDBから取得してキャッシュに入れる</li>
<li>一次データが変更されるときは関係するキャッシュを消す</li>
</ol>
<h2 id="volatile_counter_cache">volatile_counter_cache</h2>
<p>次のコードを例にして考えましょう。
tweetごとに幾つかのfavoritesを付けられるという関係になっています。</p>
<pre><code class="language-tweet.rb">class Tweet &lt; ActiveRecord::Base
  has_many :favorites
  volatile_counter_cache :favorites, cache: Rails.cache
end</code></pre>
<h3 id="counter-method">counter method</h3>
<p><code>volatile_counter_cache :favorites</code> を実行すると、<code>Tweet#favorites_count</code>というメソッドが定義されます。このメソッドは、要点で述べた「初めて必要になったときにキャッシュから取得する」「キャッシュに無ければRDBから取得してキャッシュに入れる」という処理を行うものです。具体的には、<code>volatile-counter-cache/Tweet/:id</code>というキャッシュキーでRails.cacheに問い合わせ、値が無ければ<code>favorites.size</code>を実行して結果をキャッシュに保存します。</p>
<h3 id="callback">callback</h3>
<p>また <code>volatile_counter_cache :favorites</code> により、<code>Favorite.after_create</code> と <code>Favorite.after_destroy</code> で関連するtweetのキャッシュを削除するコールバックも登録されます。要点の3で述べた「一次データが変更されるときは関係するキャッシュを消す」という処理にあたります。</p>
<h2 id="おわり-bow">おわり :bow:</h2>
<p>テーブルにカウンター用のカラムを用意したくないときの選択肢としてお使いください。どういうケースでカウンター用のカラムを用意すべきか、カウンター用のテーブルを用意すべきか、KVS等に保存すべきかという判断に迷いがあったので、とりあえず実装コストを考慮から外すべく実装を用意してみた次第です。何か分かりやすい良い指針があれば教えてください :pray: </p>

  </div>
</article>

  </main>
</body>
</html>
